
<!DOCTYPE html>


<html lang="en" data-content_root="../../../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>circStudio.analysis.models.math_models &#8212; circStudio</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../../../_static/documentation_options.js?v=2a0ef813"></script>
    <script src="../../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/circStudio/analysis/models/math_models';</script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">circStudio</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial_1.html">Opening and processing actigraphy data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial_2.html">Preprocessing actigraphy data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial_3.html">Calculating common activity and light metrics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial_4.html">Mathematical modeling of circadian rhythms</a></li>

<li class="toctree-l1"><a class="reference internal" href="../../../../api.html">API Reference</a></li>





</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for circStudio.analysis.models.math_models</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.signal</span><span class="w"> </span><span class="kn">import</span> <span class="n">find_peaks</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">odeint</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">plotly.graph_objs</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">go</span>


<div class="viewcode-block" id="Model">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Model">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Model</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Numerically integrates a system of ordinary differential equations (ODEs), whose evolution may</span>
<span class="sd">    depend on external inputs (e.g., light) and initial conditions. Time points and input data are</span>
<span class="sd">    either provided directly or extracted from a pandas.Series with a DatetimeIndex.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">        initial_conditions : numpy.ndarray</span>
<span class="sd">            Array of initial conditions for the model states.</span>
<span class="sd">        model_states : numpy.ndarray or None</span>
<span class="sd">            Array containing the model state trajectories after integration.</span>
<span class="sd">        data : pandas.Series, optional</span>
<span class="sd">            Input data series with a DatetimeIndex, where the index specifies the time points and</span>
<span class="sd">            the values represent the input variable (e.g., light intensity). Time and value arrays</span>
<span class="sd">            are extracted from this series.</span>
<span class="sd">        time : numpy.ndarray, optional</span>
<span class="sd">            Array of time points (in hours); must be monotonically increasing.</span>
<span class="sd">        inputs : numpy.ndarray, optional</span>
<span class="sd">            Array of input values (e.g., light intensity) corresponding to each time point.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">initial_conditions</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_conditions</span> <span class="o">=</span> <span class="n">initial_conditions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

        <span class="c1"># Extract time from data index</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">inputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide either light time series (data) or input and time.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">time</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span> <span class="o">=</span> <span class="n">inputs</span>


<div class="viewcode-block" id="Model.initialize_model_states">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Model.initialize_model_states">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">initialize_model_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the model states by numerically integrating the system equations.</span>

<span class="sd">        This method runs the model integration using the current initial conditions,</span>
<span class="sd">        input values, and time vector, and stores the result in `self.model_states`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrate</span><span class="p">()</span></div>



<div class="viewcode-block" id="Model.integrate">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Model.integrate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">light_vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">initial_condition</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Numerically integrates a system of ordinary differential equations (ODEs).</span>

<span class="sd">        This method uses SciPy `odeint` function to simulate the model dynamics over time, given a set of</span>
<span class="sd">        initial conditions and external inputs (e.g., light intensity). By default, it uses the class attributes</span>
<span class="sd">        `self.inputs`, `self.time`, and `self.initial_condition`, but alternative arrays can be provided.</span>

<span class="sd">        The input and time vectors must be of the same length, and the system&#39;s equations must be defined</span>
<span class="sd">        by the `derivative`method (which should be implemented within subclass of the Model class).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        light_vector (numpy.ndarray, optional):</span>
<span class="sd">            Array of input values (typically, light intensity).</span>
<span class="sd">        time_vector (numpy.ndarray, optional):</span>
<span class="sd">            Array of time points (typically, time in hours).</span>
<span class="sd">        initial_condition (numpy.ndarray, optional):</span>
<span class="sd">            Array of initial conditions.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray:</span>
<span class="sd">            Simulated state trajectories over the specified time vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">light_vector</span> <span class="o">=</span> <span class="n">light_vector</span> <span class="k">if</span> <span class="n">light_vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">inputs</span>
        <span class="n">time_vector</span> <span class="o">=</span> <span class="n">time_vector</span> <span class="k">if</span> <span class="n">time_vector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span>
        <span class="n">initial_condition</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">initial_condition</span>
            <span class="k">if</span> <span class="n">initial_condition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_conditions</span>
        <span class="p">)</span>

        <span class="c1"># Define a function to include light input</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">system_with_light</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="c1"># light_input = light_vector[min(int(t), len(light_vector) - 1)]</span>
            <span class="c1"># index = np.where(time_vector &lt;= t)[0][-1]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">time_vector</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">time_vector</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">light_input</span> <span class="o">=</span> <span class="n">light_vector</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">light_input</span><span class="p">)</span>

        <span class="c1"># Use odeint to integrate the system</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">odeint</span><span class="p">(</span><span class="n">system_with_light</span><span class="p">,</span> <span class="n">initial_condition</span><span class="p">,</span> <span class="n">time_vector</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">solution</span></div>



<div class="viewcode-block" id="Model.get_initial_conditions">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Model.get_initial_conditions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_initial_conditions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop_number</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">light_vector</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">time_vector</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempts to equilibrate the model&#39;s initial conditions by repeated simulation given a light and time vector.</span>

<span class="sd">        This method iteratively integrates the model for a user-specified number of cycles to assess whether equilibrium</span>
<span class="sd">         is achieved, as indicated by the stabilization of the predicted DLMO (Dim Light Melatonin Onset).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loop_number (int):</span>
<span class="sd">            Number of consecutive simulation cycles performed to assess whether the state trajectory of the circadian</span>
<span class="sd">            system&#39;s state variables converges to equilibrium under the given input conditions.</span>
<span class="sd">        data (pandas.Series, optional):</span>
<span class="sd">            Input data series with a DatetimeIndex. The index represents time points and the values represent input</span>
<span class="sd">            data (e.g., light intensity). The time and input arrays are extracted from this series.</span>
<span class="sd">        light_vector (numpy.ndarray, optional):</span>
<span class="sd">            Array of input values (typically, light intensity).</span>
<span class="sd">        time_vector (numpy.ndarray, optional):</span>
<span class="sd">            Array of time points (typically, time in hours).</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        numpy.ndarray:</span>
<span class="sd">            The final state of the model after attempting to reach equilibrium (either an equilibrated solution or last</span>
<span class="sd">            simulated state).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Extract time from light index</span>
        <span class="k">if</span> <span class="n">time_vector</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">light_vector</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">time_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">)</span>
                <span class="n">light_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide either light series or input and time.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time_vector</span> <span class="o">=</span> <span class="n">time_vector</span>
            <span class="n">light_vector</span> <span class="o">=</span> <span class="n">light_vector</span>

        <span class="c1"># Initialize with default initial conditions</span>
        <span class="n">initial_condition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_conditions</span>
        <span class="c1"># List to collect dlmos</span>
        <span class="n">dlmos</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">loop_number</span><span class="p">):</span>
            <span class="c1"># Calculate the solution for the models</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                <span class="n">initial_condition</span><span class="o">=</span><span class="n">initial_condition</span><span class="p">,</span>
                <span class="n">light_vector</span><span class="o">=</span><span class="n">light_vector</span><span class="p">,</span>
                <span class="n">time_vector</span><span class="o">=</span><span class="n">time_vector</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="c1"># Set current model states the solution</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span> <span class="o">=</span> <span class="n">solution</span>
            <span class="c1"># Calculate dlmos from the solution</span>
            <span class="n">dlmos</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dlmos</span><span class="p">())</span>
            <span class="c1"># Update initial_condition for the next iteration</span>
            <span class="n">initial_condition</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Exit early if entrainment is detected</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">dlmos</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dlmos</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-3</span><span class="p">):</span>
                <span class="c1"># Print number of loops required for entrainment</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The model entrained after </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> loops.&quot;</span><span class="p">)</span>
                <span class="c1"># Update model initial conditions to entrained state</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">initial_conditions</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Return entrained model solution</span>
                <span class="k">return</span> <span class="n">solution</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Non-entrainment message(free-running rhythm)</span>
        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;The model did not entrain due to insufficient loops or unentrainable light schedule.&quot;</span>
        <span class="p">)</span>
        <span class="c1"># Return unentrained model solution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_conditions</span> <span class="o">=</span> <span class="n">solution</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">solution</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>



<div class="viewcode-block" id="Model.dlmos">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Model.dlmos">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dlmos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the predicted Dim Light Melatonin Onset (DLMO) time points using a fixed,</span>
<span class="sd">        pre-specified offset (default: seven hours).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray:</span>
<span class="sd">            Array of time points (in hours) at which DLMO is expected to occur.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cbt</span><span class="p">()</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">cbt_to_dlmo</span></div>



<div class="viewcode-block" id="Model.plot">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Model.plot">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dlmo</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">cbtmin</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Create a new plotly figure</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">go</span><span class="o">.</span><span class="n">Figure</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">states</span><span class="p">:</span>
            <span class="c1"># Calculate number of states available</span>
            <span class="n">states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">==</span> <span class="s1">&#39;Forger&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">==</span> <span class="s1">&#39;Jewett&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="s1">&#39;xc&#39;</span><span class="p">,</span> <span class="s1">&#39;Light Drive&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">==</span> <span class="s1">&#39;HannaySP&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">,</span><span class="s1">&#39;Phase&#39;</span><span class="p">,</span> <span class="s1">&#39;Light Drive&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
               <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Ventral Amplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;Dorsal Amplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;Ventral Phase&#39;</span><span class="p">,</span> <span class="s1">&#39;Dorsal Phase&#39;</span><span class="p">,</span> <span class="s1">&#39;Light Drive&#39;</span><span class="p">]</span>
            <span class="c1"># Iterate over states and plot them</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">states</span><span class="p">):</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">),</span>
                    <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span>
                    <span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="p">))</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span>
                    <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Model States&#39;</span><span class="p">,</span>
                    <span class="n">xaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;Time&#39;</span><span class="p">),</span>
                    <span class="n">yaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;Model States&#39;</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">fig</span>

        <span class="k">if</span> <span class="n">dlmo</span><span class="p">:</span>
            <span class="c1"># Plot daily predicted DLMO</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span>
                <span class="n">x</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span>
                <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dlmos</span><span class="p">()</span> <span class="o">%</span> <span class="mi">24</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Predicted DLMO&#39;</span><span class="p">,</span>
            <span class="p">))</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span>
                <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Predicted DLMO&#39;</span><span class="p">,</span>
                <span class="n">xaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;Day&#39;</span><span class="p">),</span>
                <span class="n">yaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;DLMO time&#39;</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">fig</span>

        <span class="k">if</span> <span class="n">cbtmin</span><span class="p">:</span>
            <span class="c1"># Plot daily predicted DLMO</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">add_trace</span><span class="p">(</span><span class="n">go</span><span class="o">.</span><span class="n">Scatter</span><span class="p">(</span>
                <span class="n">x</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">date</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">))</span><span class="o">.</span><span class="n">unique</span><span class="p">(),</span>
                <span class="n">y</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cbt</span><span class="p">()</span> <span class="o">%</span> <span class="mi">24</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Predicted CBTmin&#39;</span><span class="p">,</span>
            <span class="p">))</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">update_layout</span><span class="p">(</span>
                <span class="n">title</span><span class="o">=</span><span class="s1">&#39;Predicted CBTmin&#39;</span><span class="p">,</span>
                <span class="n">xaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;Day&#39;</span><span class="p">),</span>
                <span class="n">yaxis</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s1">&#39;CBTmin time&#39;</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">fig</span></div>
</div>



<div class="viewcode-block" id="Forger">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Forger">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Forger</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements the mathematical model of human circadian rhythms developed by Forger, Jewett and Kronauer [1].</span>
<span class="sd">    The formalism includes a representation of the biochemical conversion of the light signal into a drive on</span>
<span class="sd">    the circadian pacemaker, which is modeled as a van der Pol oscillator. This cubic model is characterized</span>
<span class="sd">    by three state variables: x, xc and n. While n can be interpreted as the proportion of activated photoreceptors,</span>
<span class="sd">    at a given time, x and xc cannot directly be mapped to specific physiological mechanisms. Instead, x and xc are</span>
<span class="sd">    used to predict biologically meaningful quantities, such as the core body temperature minimum (CBTmin).</span>

<span class="sd">    Our implementation closely follows the approach of the `circadian`package by Arcascope [2]. However, we use the</span>
<span class="sd">    more powerful LSODA integrator (via SciPy&#39;s `odeint`) for numerical integration, enabling the integration of the</span>
<span class="sd">    system using more complex light trajectories.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    taux : float</span>
<span class="sd">        Intrinsic period of the oscillator (hours).</span>
<span class="sd">    mu : float</span>
<span class="sd">        Nonlinearity parameter of the van der Pol oscillator.</span>
<span class="sd">    g : float</span>
<span class="sd">        Light sensitivity scaling parameter.</span>
<span class="sd">    alpha_0 : float</span>
<span class="sd">        Baseline light sensitivity parameter.</span>
<span class="sd">    beta : float</span>
<span class="sd">        Rate constant for adaptation variable n.</span>
<span class="sd">    p : float</span>
<span class="sd">        Power-law exponent for light input.</span>
<span class="sd">    i0 : float</span>
<span class="sd">        Saturation intensity for light sensitivity (lux).</span>
<span class="sd">    k : float</span>
<span class="sd">        Scaling factor for light-dependent changes in oscillator period.</span>
<span class="sd">    cbt_to_dlmo : float</span>
<span class="sd">        Time offset (in hours) from CBTmin to DLMO.</span>
<span class="sd">    initial_conditions : numpy.ndarray</span>
<span class="sd">        State vector at the start of simulation (default: [-0.0843259, -1.09607546, 0.45584306]).</span>
<span class="sd">    model_states : numpy.ndarray</span>
<span class="sd">        Integrated state trajectories of the model.</span>
<span class="sd">    time : numpy.ndarray</span>
<span class="sd">        Array of time points for simulation.</span>
<span class="sd">    inputs : numpy.ndarray</span>
<span class="sd">        Array of input values (e.g., light intensity) over time.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    derivative(t, state, light)</span>
<span class="sd">        Computes the derivatives of the state variables at a given time and light input.</span>
<span class="sd">    amplitude()</span>
<span class="sd">        Calculates the amplitude of the oscillator from integrated states.</span>
<span class="sd">    phase()</span>
<span class="sd">        Calculates the phase angle of the oscillator from integrated states.</span>
<span class="sd">    cbt()</span>
<span class="sd">        Identifies the timing of core body temperature minima from integrated states.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Forger DB, Jewett ME, Kronauer RE. A Simpler Model of the Human Circadian Pacemaker.</span>
<span class="sd">    Journal of Biological Rhythms. 1999;14(6):533-538. doi:10.1177/074873099129000867</span>

<span class="sd">    [2] Tavella, F., Hannay, K., &amp; Walch, O. (2023). Arcascope/circadian: Refactoring of readers</span>
<span class="sd">    and metrics modules, Zenodo, v1.0.2. https://doi.org/10.5281/zenodo.8206871</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">taux</span><span class="o">=</span><span class="mf">24.2</span><span class="p">,</span>
        <span class="n">mu</span><span class="o">=</span><span class="mf">0.23</span><span class="p">,</span>
        <span class="n">g</span><span class="o">=</span><span class="mf">33.75</span><span class="p">,</span>
        <span class="n">alpha_0</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
        <span class="n">beta</span><span class="o">=</span><span class="mf">0.0075</span><span class="p">,</span>
        <span class="n">p</span><span class="o">=</span><span class="mf">0.50</span><span class="p">,</span>
        <span class="n">i0</span><span class="o">=</span><span class="mf">9500.0</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="mf">0.55</span><span class="p">,</span>
        <span class="n">cbt_to_dlmo</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span>
        <span class="n">initial_condition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">inputs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">initial_conditions</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.0843259</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.09607546</span><span class="p">,</span> <span class="mf">0.45584306</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">initial_conditions</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.0843259</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.09607546</span><span class="p">,</span> <span class="mf">0.45584306</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="c1"># Check for a scenario in which a initial condition is provided</span>
        <span class="k">if</span> <span class="n">initial_condition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_conditions</span> <span class="o">=</span> <span class="n">initial_condition</span>
        <span class="c1"># self.initial_conditions = np.array([-0.0843259, -1.09607546, 0.45584306])</span>
        <span class="c1"># self.inputs = inputs</span>
        <span class="c1"># self.time = time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taux</span> <span class="o">=</span> <span class="n">taux</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_0</span> <span class="o">=</span> <span class="n">alpha_0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i0</span> <span class="o">=</span> <span class="n">i0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cbt_to_dlmo</span> <span class="o">=</span> <span class="n">cbt_to_dlmo</span>
        <span class="c1"># self.model_states = self.integrate()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_model_states</span><span class="p">()</span>

<div class="viewcode-block" id="Forger.derivative">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Forger.derivative">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">light</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the derivatives of the state variables at a given time and light input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : float</span>
<span class="sd">            Current simulation time (in hours).</span>
<span class="sd">        state : numpy.ndarray</span>
<span class="sd">            Current values of the state variables at time t.</span>
<span class="sd">        light : float</span>
<span class="sd">            Light intensity input (in lux) at time t.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Derivatives at time t.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_0</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">((</span><span class="n">light</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">i0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span>
        <span class="n">Bhat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.4</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.4</span> <span class="o">*</span> <span class="n">xc</span><span class="p">)</span>
        <span class="n">mu_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">*</span> <span class="p">(</span><span class="n">xc</span> <span class="o">-</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="n">xc</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">))</span>
        <span class="n">taux_term</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mf">24.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">0.99669</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">taux</span><span class="p">),</span> <span class="mf">2.0</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span> <span class="n">Bhat</span>

        <span class="n">dydt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">dydt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">xc</span> <span class="o">+</span> <span class="n">Bhat</span><span class="p">)</span>
        <span class="n">dydt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">12.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">mu_term</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">taux_term</span><span class="p">)</span>
        <span class="n">dydt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">60.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dydt</span></div>


<div class="viewcode-block" id="Forger.amplitude">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Forger.amplitude">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">amplitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Amplitude of the oscillator computed from the integrated state trajectory.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Amplitude at each time point: sqrt(x^2 + xc^2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Integrate model and extract amplitude</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">xc</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Forger.phase">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Forger.phase">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the phase angle of the oscillator computed from the integrated state trajectory.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Phase angle (radians) at each time point: arctangent(xc/x).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Integrate model and extract phase</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Multiplying xc makes the phase move clockwise</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Observe that np.angle(x + complex(0,1) * xc) == np.atan2(xc,x)</span>
        <span class="c1"># The y (in this case, xc) appears first in the atan2 formula</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">xc</span><span class="p">)</span></div>

        <span class="c1"># return np.atan2(xc,x)</span>

<div class="viewcode-block" id="Forger.cbt">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Forger.cbt">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cbt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time points corresponding to the predicted core bod temperature minima (CBTmin), derived from the</span>
<span class="sd">        state variable x.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of time points (in hours) where minima of x occur, corresponding to the CBTmin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate time step (dt) between consecutive time points</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Invert cos(x) to turn the minima into maxima (peaks)</span>
        <span class="n">inverted_x</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Identify the indices where the minima occur</span>
        <span class="n">cbt_min_indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">inverted_x</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">13.0</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
        <span class="c1"># Use the previous indices to find the cbtmin times</span>
        <span class="n">cbtmin_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">cbt_min_indices</span><span class="p">]</span>
        <span class="c1"># if you want to know in clock time, just do cbtmin_times % 24</span>
        <span class="k">return</span> <span class="n">cbtmin_times</span></div>
</div>



<div class="viewcode-block" id="Jewett">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Jewett">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Jewett</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements a refined version of the Forger, Jewett and Kronauer (FJK) model of human circadian rhythms,</span>
<span class="sd">    containing a nonlinearity of degree seven [1]. Compared to the FJK model implemented in the Forger subclass,</span>
<span class="sd">    the revised model recovers strength more slowly when the rhythm is very weak (low amplitude), but recovers</span>
<span class="sd">    faster once it is close to a stable rhythm (high amplitude).</span>

<span class="sd">    This model is characterized by three state variables: x, xc and n. While n can be interpreted as the proportion</span>
<span class="sd">    of activated photoreceptors, at a given time, x and xc cannot directly be mapped to specific physiological</span>
<span class="sd">    mechanisms. Instead, x and xc are used to predict biologically meaningful quantities, such as the core body</span>
<span class="sd">    temperature minimum (CBTmin).</span>

<span class="sd">    Our implementation closely follows the approach of the `circadian`package by Arcascope [2]. However, we use the</span>
<span class="sd">    more powerful LSODA integrator (via SciPy&#39;s `odeint`) for numerical integration, enabling the integration of the</span>
<span class="sd">    system using more complex light trajectories.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    taux : float</span>
<span class="sd">        Intrinsic period of the oscillator (hours).</span>
<span class="sd">    mu : float</span>
<span class="sd">        Nonlinearity parameter of the van der Pol oscillator.</span>
<span class="sd">    g : float</span>
<span class="sd">        Light sensitivity scaling parameter.</span>
<span class="sd">    alpha_0 : float</span>
<span class="sd">        Baseline light sensitivity parameter.</span>
<span class="sd">    beta : float</span>
<span class="sd">        Rate constant for adaptation variable n.</span>
<span class="sd">    p : float</span>
<span class="sd">        Power-law exponent for light input.</span>
<span class="sd">    i0 : float</span>
<span class="sd">        Saturation intensity for light sensitivity (lux).</span>
<span class="sd">    k : float</span>
<span class="sd">        Scaling factor for light-dependent changes in oscillator period.</span>
<span class="sd">    q : float</span>
<span class="sd">        Coefficient for light-dependent feedback in xc dynamics.</span>
<span class="sd">    phi_ref : float</span>
<span class="sd">        Reference phase parameter for phase computations.</span>
<span class="sd">    cbt_to_dlmo : float</span>
<span class="sd">        Time offset (in hours) from CBTmin to DLMO.</span>
<span class="sd">    initial_conditions : numpy.ndarray</span>
<span class="sd">        State vector at the start of simulation (default: [-0.10097101, -1.21985662, 0.50529415]).</span>
<span class="sd">    model_states : numpy.ndarray</span>
<span class="sd">        Integrated state trajectories of the model.</span>
<span class="sd">    time : numpy.ndarray</span>
<span class="sd">        Array of time points for simulation.</span>
<span class="sd">    inputs : numpy.ndarray</span>
<span class="sd">        Array of input values (e.g., light intensity) over time.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    derivative(t, state, light)</span>
<span class="sd">        Computes the derivatives of the state variables at a given time and light input.</span>
<span class="sd">    amplitude()</span>
<span class="sd">        Calculates the amplitude of the oscillator from integrated states.</span>
<span class="sd">    phase()</span>
<span class="sd">        Calculates the phase angle of the oscillator from integrated states.</span>
<span class="sd">    cbt()</span>
<span class="sd">        Identifies the timing of core body temperature minima from integrated states.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Jewett ME, Forger DB, Kronauer RE. Revised Limit Cycle Oscillator Model of Human Circadian</span>
<span class="sd">    Pacemaker. Journal of Biological Rhythms. 1999;14(6):493-500. https://doi.org/10.1177/074873049901400608</span>

<span class="sd">    [2] Tavella, F., Hannay, K., &amp; Walch, O. (2023). Arcascope/circadian: Refactoring of readers</span>
<span class="sd">    and metrics modules, Zenodo, v1.0.2. https://doi.org/10.5281/zenodo.8206871</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">taux</span><span class="o">=</span><span class="mf">24.2</span><span class="p">,</span>
        <span class="n">mu</span><span class="o">=</span><span class="mf">0.13</span><span class="p">,</span>
        <span class="n">g</span><span class="o">=</span><span class="mf">19.875</span><span class="p">,</span>
        <span class="n">beta</span><span class="o">=</span><span class="mf">0.013</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="mf">0.55</span><span class="p">,</span>
        <span class="n">q</span><span class="o">=</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span><span class="p">,</span>
        <span class="n">i0</span><span class="o">=</span><span class="mi">9500</span><span class="p">,</span>
        <span class="n">p</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
        <span class="n">alpha_0</span><span class="o">=</span><span class="mf">0.16</span><span class="p">,</span>
        <span class="n">phi_ref</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
        <span class="n">cbt_to_dlmo</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span>
        <span class="n">initial_condition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">inputs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">initial_conditions</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.10097101</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.21985662</span><span class="p">,</span> <span class="mf">0.50529415</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">initial_conditions</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.10097101</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.21985662</span><span class="p">,</span> <span class="mf">0.50529415</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="c1"># Check for a scenario in which a initial condition is provided</span>
        <span class="k">if</span> <span class="n">initial_condition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_conditions</span> <span class="o">=</span> <span class="n">initial_condition</span>

        <span class="c1"># self.initial_conditions= np.array([-0.10097101, -1.21985662, 0.50529415])</span>
        <span class="c1"># self.inputs = inputs</span>
        <span class="c1"># self.time = time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taux</span> <span class="o">=</span> <span class="n">taux</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">=</span> <span class="n">q</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i0</span> <span class="o">=</span> <span class="n">i0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_0</span> <span class="o">=</span> <span class="n">alpha_0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phi_ref</span> <span class="o">=</span> <span class="n">phi_ref</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cbt_to_dlmo</span> <span class="o">=</span> <span class="n">cbt_to_dlmo</span>
        <span class="c1"># self.model_states = self.integrate()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_model_states</span><span class="p">()</span>

<div class="viewcode-block" id="Jewett.derivative">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Jewett.derivative">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">light</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the derivatives of the state variables at a given time and light input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : float</span>
<span class="sd">            Current simulation time (in hours).</span>
<span class="sd">        state : numpy.ndarray</span>
<span class="sd">            Current values of the state variables at time t.</span>
<span class="sd">        light : float</span>
<span class="sd">            Light intensity input (in lux) at time t.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Derivatives at time t.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_0</span> <span class="o">*</span> <span class="p">(</span><span class="n">light</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">i0</span><span class="p">)</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span>
        <span class="n">Bhat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">*</span> <span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.4</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="mf">0.4</span> <span class="o">*</span> <span class="n">xc</span><span class="p">)</span>
        <span class="n">mu_term</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mf">4.0</span> <span class="o">/</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="mf">256.0</span> <span class="o">/</span> <span class="mf">105.0</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">7</span><span class="p">)</span>
        <span class="n">taux_term</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="mf">24.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">0.99729</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">taux</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span> <span class="n">Bhat</span>

        <span class="n">dydt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">dydt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">12</span> <span class="o">*</span> <span class="p">(</span><span class="n">xc</span> <span class="o">+</span> <span class="n">mu_term</span> <span class="o">+</span> <span class="n">Bhat</span><span class="p">)</span>
        <span class="n">dydt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">12</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q</span> <span class="o">*</span> <span class="n">Bhat</span> <span class="o">*</span> <span class="n">xc</span> <span class="o">-</span> <span class="n">x</span> <span class="o">*</span> <span class="n">taux_term</span><span class="p">)</span>
        <span class="n">dydt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">60.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dydt</span></div>


<div class="viewcode-block" id="Jewett.amplitude">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Jewett.amplitude">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">amplitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Amplitude of the oscillator computed from the integrated state trajectory.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Amplitude at each time point: sqrt(x^2 + xc^2).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Integrate model and extract amplitude</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">xc</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="Jewett.phase">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Jewett.phase">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the phase angle of the oscillator computed from the integrated state trajectory.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Phase angle (radians) at each time point: arctangent(xc/x).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Integrate model and extract phase</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Multiplying xc makes the phase move clockwise</span>
        <span class="n">xc</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Observe that np.angle(x + complex(0,1) * xc) == np.atan2(xc,x)</span>
        <span class="c1"># The y (in this case, xc) appears first in the atan2 formula</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">xc</span><span class="p">)</span></div>

        <span class="c1"># return np.atan2(xc,x)</span>

<div class="viewcode-block" id="Jewett.cbt">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.Jewett.cbt">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cbt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time points corresponding to the predicted core bod temperature minima (CBTmin), derived from the</span>
<span class="sd">        state variable x.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of time points (in hours) where minima of x occur, corresponding to the CBTmin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate time step (dt) between consecutive time points</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Invert cos(x) to turn the minima into maxima (peaks)</span>
        <span class="n">inverted_x</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Identify the indices where the minima occur</span>
        <span class="n">cbt_min_indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">inverted_x</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">13.0</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
        <span class="c1"># Use the previous indices to find the cbtmin times</span>
        <span class="n">cbtmin_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">cbt_min_indices</span><span class="p">]</span>
        <span class="c1"># if you want to know in clock time, just do cbtmin_times % 24</span>
        <span class="k">return</span> <span class="n">cbtmin_times</span></div>
</div>



<div class="viewcode-block" id="HannaySP">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.HannaySP">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HannaySP</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements the Hannay Single-Population (SP) model of human circadian rhythms [1]. It describes a population of</span>
<span class="sd">    weakly-coupled oscillators using a formalism with three state variables: R (collective amplitude), Psi (collective</span>
<span class="sd">    phase), and n (proportion of light receptors used). In contrast to the FJK formalism, all three state variables are</span>
<span class="sd">    directly biologically interpretable. The model is derived from the mathematical description of the rhythm within</span>
<span class="sd">    individual cells in the suprachiasmatic nucleus (SCN) of the hypothalamus, from which a coherent behavior emerges.</span>

<span class="sd">    Our implementation closely follows the approach of the `circadian`package by Arcascope [2]. However, we use the</span>
<span class="sd">    more powerful LSODA integrator (via SciPy&#39;s `odeint`) for numerical integration, enabling the integration of the</span>
<span class="sd">    system using more complex light trajectories.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    tau : float</span>
<span class="sd">        Intrinsic period of the oscillator (hours).</span>
<span class="sd">    k : float</span>
<span class="sd">        Coupling strength parameter.</span>
<span class="sd">    gamma : float</span>
<span class="sd">        Amplitude relaxation parameter.</span>
<span class="sd">    beta : float</span>
<span class="sd">        Phase response parameter.</span>
<span class="sd">    a1 : float</span>
<span class="sd">        Amplitude of first-harmonic light effect.</span>
<span class="sd">    a2 : float</span>
<span class="sd">        Amplitude of second-harmonic light effect.</span>
<span class="sd">    betal1 : float</span>
<span class="sd">        Phase offset for first-harmonic light effect (radians).</span>
<span class="sd">    betal2 : float</span>
<span class="sd">        Phase offset for second-harmonic light effect (radians).</span>
<span class="sd">    sigma : float</span>
<span class="sd">        Baseline light-induced phase shift parameter.</span>
<span class="sd">    g : float</span>
<span class="sd">        Light sensitivity scaling parameter.</span>
<span class="sd">    alpha_0 : float</span>
<span class="sd">        Baseline light sensitivity parameter.</span>
<span class="sd">    delta : float</span>
<span class="sd">        Rate constant for adaptation variable n.</span>
<span class="sd">    p : float</span>
<span class="sd">        Power-law exponent for light input.</span>
<span class="sd">    i0 : float</span>
<span class="sd">        Saturation intensity for light sensitivity (lux).</span>
<span class="sd">    cbt_to_dlmo : float</span>
<span class="sd">        Time offset (in hours) from CBTmin to DLMO.</span>
<span class="sd">    initial_conditions : numpy.ndarray</span>
<span class="sd">        State vector at the start of simulation (default: [0.82041911, 1.71383697, 0.52318122]).</span>
<span class="sd">    model_states : numpy.ndarray</span>
<span class="sd">        Integrated state trajectories of the model.</span>
<span class="sd">    time : numpy.ndarray</span>
<span class="sd">        Array of time points for simulation.</span>
<span class="sd">    inputs : numpy.ndarray</span>
<span class="sd">        Array of input values (e.g., light intensity) over time.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    derivative(t, state, light)</span>
<span class="sd">        Computes the derivatives of the state variables at a given time and light input.</span>
<span class="sd">    amplitude()</span>
<span class="sd">        Returns the collective rhythm amplitude (R) over time.</span>
<span class="sd">    phase()</span>
<span class="sd">        Returns the collective phase (Psi) as a wrapped angle over time.</span>
<span class="sd">    cbt()</span>
<span class="sd">        Identifies the timing of core body temperature minima from the phase trajectory.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Hannay KM, Booth V, Forger DB. Macroscopic Models for Human Circadian Rhythms.</span>
<span class="sd">    Journal of Biological Rhythms. 2019;34(6):658-671. https://doi.org/10.1177/0748730419878298</span>

<span class="sd">    [2] Tavella, F., Hannay, K., &amp; Walch, O. (2023). Arcascope/circadian: Refactoring of readers</span>
<span class="sd">    and metrics modules, Zenodo, v1.0.2. https://doi.org/10.5281/zenodo.8206871</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tau</span><span class="o">=</span><span class="mf">23.84</span><span class="p">,</span>
        <span class="n">k</span><span class="o">=</span><span class="mf">0.06358</span><span class="p">,</span>
        <span class="n">gamma</span><span class="o">=</span><span class="mf">0.024</span><span class="p">,</span>
        <span class="n">beta</span><span class="o">=-</span><span class="mf">0.09318</span><span class="p">,</span>
        <span class="n">a1</span><span class="o">=</span><span class="mf">0.3855</span><span class="p">,</span>
        <span class="n">a2</span><span class="o">=</span><span class="mf">0.1977</span><span class="p">,</span>
        <span class="n">betal1</span><span class="o">=-</span><span class="mf">0.0026</span><span class="p">,</span>
        <span class="n">betal2</span><span class="o">=-</span><span class="mf">0.957756</span><span class="p">,</span>
        <span class="n">sigma</span><span class="o">=</span><span class="mf">0.0400692</span><span class="p">,</span>
        <span class="n">g</span><span class="o">=</span><span class="mf">33.75</span><span class="p">,</span>
        <span class="n">alpha_0</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
        <span class="n">delta</span><span class="o">=</span><span class="mf">0.0075</span><span class="p">,</span>
        <span class="n">p</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
        <span class="n">i0</span><span class="o">=</span><span class="mf">9325.0</span><span class="p">,</span>
        <span class="n">cbt_to_dlmo</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span>
        <span class="n">initial_condition</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">inputs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">initial_conditions</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.82041911</span><span class="p">,</span> <span class="mf">1.71383697</span><span class="p">,</span> <span class="mf">0.52318122</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">initial_conditions</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.82041911</span><span class="p">,</span> <span class="mf">1.71383697</span><span class="p">,</span> <span class="mf">0.52318122</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="c1"># Check for a scenario in which a initial condition is provided</span>
        <span class="k">if</span> <span class="n">initial_condition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_conditions</span> <span class="o">=</span> <span class="n">initial_condition</span>
        <span class="c1"># self.initial_conditions = np.array([0.82041911, 1.71383697, 0.52318122])</span>
        <span class="c1"># self.inputs = inputs</span>
        <span class="c1"># self.time = time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">tau</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span> <span class="o">=</span> <span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a2</span> <span class="o">=</span> <span class="n">a2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">betal1</span> <span class="o">=</span> <span class="n">betal1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">betal2</span> <span class="o">=</span> <span class="n">betal2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_0</span> <span class="o">=</span> <span class="n">alpha_0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i0</span> <span class="o">=</span> <span class="n">i0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cbt_to_dlmo</span> <span class="o">=</span> <span class="n">cbt_to_dlmo</span>
        <span class="c1"># self.model_states = self.integrate()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_model_states</span><span class="p">()</span>

<div class="viewcode-block" id="HannaySP.derivative">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.HannaySP.derivative">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">light</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the derivatives of the state variables at a given time and light input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : float</span>
<span class="sd">            Current simulation time (in hours).</span>
<span class="sd">        state : numpy.ndarray</span>
<span class="sd">            Current values of the state variables at time t.</span>
<span class="sd">        light : float</span>
<span class="sd">            Light intensity input (in lux) at time t.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Derivatives at time t.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Psi</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_0</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="n">light</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">light</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">i0</span><span class="p">)</span>

        <span class="n">Bhat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">alpha</span>
        <span class="n">A1_term_amp</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">Bhat</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nb">pow</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Psi</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">betal1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">A2_term_amp</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a2</span>
            <span class="o">*</span> <span class="mf">0.5</span>
            <span class="o">*</span> <span class="n">Bhat</span>
            <span class="o">*</span> <span class="n">R</span>
            <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nb">pow</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">))</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">Psi</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">betal2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">LightAmp</span> <span class="o">=</span> <span class="n">A1_term_amp</span> <span class="o">+</span> <span class="n">A2_term_amp</span>
        <span class="n">A1_term_phase</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">*</span> <span class="n">Bhat</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">R</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Psi</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">betal1</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">A2_term_phase</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a2</span> <span class="o">*</span> <span class="n">Bhat</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">Psi</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">betal2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">LightPhase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">Bhat</span> <span class="o">-</span> <span class="n">A1_term_phase</span> <span class="o">-</span> <span class="n">A2_term_phase</span>

        <span class="n">dydt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">dydt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">R</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nb">pow</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">))</span>
            <span class="o">+</span> <span class="n">LightAmp</span>
        <span class="p">)</span>
        <span class="n">dydt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tau</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">))</span>
            <span class="o">+</span> <span class="n">LightPhase</span>
        <span class="p">)</span>
        <span class="n">dydt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">60.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dydt</span></div>


<div class="viewcode-block" id="HannaySP.amplitude">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.HannaySP.amplitude">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">amplitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collective rhythm amplitude (R) of the oscillator population.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Amplitude (R) at each time point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Integrate model and extract collective rhythm amplitude (r)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="HannaySP.phase">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.HannaySP.phase">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collective ventral phase (Psi) of the oscillator population, wrapped to [-pi,pi].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Phase angle (radians) at each time point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Integrate model and extract collective phase (phi)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="HannaySP.cbt">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.HannaySP.cbt">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cbt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time points corresponding to the predicted core bod temperature minima (CBTmin), derived from the</span>
<span class="sd">        collective phase trajectory.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of time points (in hours) where minima of cos(Psi) occur, corresponding to the CBTmin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate time step (dt) between consecutive time points</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Invert cos(x) to turn the minima into maxima (peaks)</span>
        <span class="n">inverted_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Identify the indices where the minima occur</span>
        <span class="n">cbt_min_indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">inverted_x</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">13.0</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
        <span class="c1"># Use the previous indices to find the cbtmin times</span>
        <span class="n">cbtmin_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">cbt_min_indices</span><span class="p">]</span>
        <span class="c1"># if you want to know in clock time, just do cbtmin_times % 24</span>
        <span class="k">return</span> <span class="n">cbtmin_times</span></div>
</div>



<div class="viewcode-block" id="HannayTP">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.HannayTP">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">HannayTP</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements the Hannay Two-Population (TP) model of human circadian rhythms [1]. The neuroanatomy of the</span>
<span class="sd">    suprachiasmatic nucleus (SCN) in the hypothalamus distinguishes two primary populations: the ventral cluster,</span>
<span class="sd">    which receives most light input, and the dorsal cluster. To better reflect this neurophysiological organization,</span>
<span class="sd">    Hannay et al. extended the Single Population (SP) model to explicitly represent both the ventral and dorsal</span>
<span class="sd">    groups, resulting in the TP model. Similar to the HannaySP, all five state variables are directly biologically</span>
<span class="sd">    interpretable. The model is also derived from the mathematical description of the rhythm within individual cells,</span>
<span class="sd">    from which a coherent behavior emerges.</span>

<span class="sd">    Our implementation closely follows the approach of the `circadian`package by Arcascope [2]. However, we use the</span>
<span class="sd">    more powerful LSODA integrator (via SciPy&#39;s `odeint`) for numerical integration, enabling the integration of the</span>
<span class="sd">    system using more complex light trajectories.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    tauv : float</span>
<span class="sd">        Intrinsic period of the ventral oscillator (hours).</span>
<span class="sd">    taud : float</span>
<span class="sd">        Intrinsic period of the dorsal oscillator (hours).</span>
<span class="sd">    kvv : float</span>
<span class="sd">        Intrinsic coupling strength within the ventral oscillator population.</span>
<span class="sd">    kdd : float</span>
<span class="sd">        Intrinsic coupling strength within the dorsal oscillator population.</span>
<span class="sd">    kvd : float</span>
<span class="sd">        Coupling strength from ventral to dorsal population.</span>
<span class="sd">    kdv : float</span>
<span class="sd">        Coupling strength from dorsal to ventral population.</span>
<span class="sd">    gamma : float</span>
<span class="sd">        Amplitude relaxation parameter.</span>
<span class="sd">    a1 : float</span>
<span class="sd">        Amplitude of first-harmonic light effect.</span>
<span class="sd">    a2 : float</span>
<span class="sd">        Amplitude of second-harmonic light effect.</span>
<span class="sd">    betal : float</span>
<span class="sd">        Phase offset for first-harmonic light effect (radians).</span>
<span class="sd">    betal2 : float</span>
<span class="sd">        Phase offset for second-harmonic light effect (radians).</span>
<span class="sd">    sigma : float</span>
<span class="sd">        Baseline light-induced phase shift parameter.</span>
<span class="sd">    g : float</span>
<span class="sd">        Light sensitivity scaling parameter.</span>
<span class="sd">    alpha_0 : float</span>
<span class="sd">        Baseline light sensitivity parameter.</span>
<span class="sd">    delta : float</span>
<span class="sd">        Rate constant for adaptation variable n.</span>
<span class="sd">    p : float</span>
<span class="sd">        Power-law exponent for light input.</span>
<span class="sd">    i0 : float</span>
<span class="sd">        Saturation intensity for light sensitivity (lux).</span>
<span class="sd">    cbt_to_dlmo : float</span>
<span class="sd">        Time offset (in hours) from CBTmin to DLMO.</span>
<span class="sd">    initial_conditions : numpy.ndarray</span>
<span class="sd">        State vector at the start of simulation (default: [0.82423745, 0.82304996, 1.75233424, 1.863457, 0.52318122]).</span>
<span class="sd">    model_states : numpy.ndarray</span>
<span class="sd">        Integrated state trajectories of the model.</span>
<span class="sd">    time : numpy.ndarray</span>
<span class="sd">        Array of time points for simulation.</span>
<span class="sd">    inputs : numpy.ndarray</span>
<span class="sd">        Array of input values (e.g., light intensity) over time.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    derivative(t, state, light)</span>
<span class="sd">        Computes the derivatives of the state variables at a given time and light input.</span>
<span class="sd">    amplitude()</span>
<span class="sd">        Returns the collective ventral rhythm amplitude (Rv) over time.</span>
<span class="sd">    phase()</span>
<span class="sd">        Returns the collective ventral phase (Psiv) as a wrapped angle over time.</span>
<span class="sd">    cbt()</span>
<span class="sd">        Identifies the timing of core body temperature minima based on the ventral phase trajectory.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    [1] Hannay KM, Booth V, Forger DB. Macroscopic Models for Human Circadian Rhythms.</span>
<span class="sd">    Journal of Biological Rhythms. 2019;34(6):658-671. https://doi.org/10.1177/0748730419878298</span>

<span class="sd">    [2] Tavella, F., Hannay, K., &amp; Walch, O. (2023). Arcascope/circadian: Refactoring of readers</span>
<span class="sd">    and metrics modules, Zenodo, v1.0.2. https://doi.org/10.5281/zenodo.8206871</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">tauv</span><span class="o">=</span><span class="mf">24.25</span><span class="p">,</span>
        <span class="n">taud</span><span class="o">=</span><span class="mf">24.0</span><span class="p">,</span>
        <span class="n">kvv</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
        <span class="n">kdd</span><span class="o">=</span><span class="mf">0.04</span><span class="p">,</span>
        <span class="n">kvd</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
        <span class="n">kdv</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span>
        <span class="n">gamma</span><span class="o">=</span><span class="mf">0.024</span><span class="p">,</span>
        <span class="n">a1</span><span class="o">=</span><span class="mf">0.440068</span><span class="p">,</span>
        <span class="n">a2</span><span class="o">=</span><span class="mf">0.159136</span><span class="p">,</span>
        <span class="n">betal</span><span class="o">=</span><span class="mf">0.06452</span><span class="p">,</span>
        <span class="n">betal2</span><span class="o">=-</span><span class="mf">1.38935</span><span class="p">,</span>
        <span class="n">sigma</span><span class="o">=</span><span class="mf">0.0477375</span><span class="p">,</span>
        <span class="n">g</span><span class="o">=</span><span class="mf">33.75</span><span class="p">,</span>
        <span class="n">alpha_0</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
        <span class="n">delta</span><span class="o">=</span><span class="mf">0.0075</span><span class="p">,</span>
        <span class="n">p</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span>
        <span class="n">i0</span><span class="o">=</span><span class="mf">9325.0</span><span class="p">,</span>
        <span class="n">cbt_to_dlmo</span><span class="o">=</span><span class="mf">7.0</span><span class="p">,</span>
        <span class="n">initial_condition</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">inputs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span>
                <span class="n">initial_conditions</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.82423745</span><span class="p">,</span> <span class="mf">0.82304996</span><span class="p">,</span> <span class="mf">1.75233424</span><span class="p">,</span> <span class="mf">1.863457</span><span class="p">,</span> <span class="mf">0.52318122</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
                <span class="n">inputs</span><span class="o">=</span><span class="n">inputs</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span>
                <span class="n">initial_conditions</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.82423745</span><span class="p">,</span> <span class="mf">0.82304996</span><span class="p">,</span> <span class="mf">1.75233424</span><span class="p">,</span> <span class="mf">1.863457</span><span class="p">,</span> <span class="mf">0.52318122</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="c1"># Check for a scenario in which a initial condition is provided</span>
        <span class="k">if</span> <span class="n">initial_condition</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initial_conditions</span> <span class="o">=</span> <span class="n">initial_condition</span>

        <span class="c1"># self.initial_conditions = np.array([0.82423745, 0.82304996, 1.75233424, 1.863457, 0.52318122])</span>
        <span class="c1"># self.inputs = inputs</span>
        <span class="c1"># self.time = time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tauv</span> <span class="o">=</span> <span class="n">tauv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">taud</span> <span class="o">=</span> <span class="n">taud</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kvv</span> <span class="o">=</span> <span class="n">kvv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kdd</span> <span class="o">=</span> <span class="n">kdd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kvd</span> <span class="o">=</span> <span class="n">kvd</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kdv</span> <span class="o">=</span> <span class="n">kdv</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a2</span> <span class="o">=</span> <span class="n">a2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">betal</span> <span class="o">=</span> <span class="n">betal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">betal2</span> <span class="o">=</span> <span class="n">betal2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">=</span> <span class="n">g</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha_0</span> <span class="o">=</span> <span class="n">alpha_0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">i0</span> <span class="o">=</span> <span class="n">i0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cbt_to_dlmo</span> <span class="o">=</span> <span class="n">cbt_to_dlmo</span>
        <span class="c1"># self.model_states = self.integrate()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initialize_model_states</span><span class="p">()</span>

<div class="viewcode-block" id="HannayTP.derivative">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.HannayTP.derivative">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">light</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the derivatives of the state variables at a given time and light input.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        t : float</span>
<span class="sd">            Current simulation time (in hours).</span>
<span class="sd">        state : numpy.ndarray</span>
<span class="sd">            Current values of the state variables at time t.</span>
<span class="sd">        light : float</span>
<span class="sd">            Light intensity input (in lux) at time t.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Derivatives at time t.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Rv</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Rd</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Psiv</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">Psid</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha_0</span> <span class="o">*</span> <span class="nb">pow</span><span class="p">(</span><span class="n">light</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">light</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">i0</span><span class="p">)</span>
        <span class="n">Bhat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="n">alpha</span>

        <span class="n">A1_term_amp</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">Bhat</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nb">pow</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Psiv</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">betal</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">A2_term_amp</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a2</span>
            <span class="o">*</span> <span class="mf">0.5</span>
            <span class="o">*</span> <span class="n">Bhat</span>
            <span class="o">*</span> <span class="n">Rv</span>
            <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nb">pow</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">))</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">Psiv</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">betal2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">LightAmp</span> <span class="o">=</span> <span class="n">A1_term_amp</span> <span class="o">+</span> <span class="n">A2_term_amp</span>
        <span class="n">A1_term_phase</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">*</span> <span class="n">Bhat</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">Rv</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Psiv</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">betal</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">A2_term_phase</span> <span class="o">=</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a2</span>
            <span class="o">*</span> <span class="n">Bhat</span>
            <span class="o">*</span> <span class="mf">0.5</span>
            <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="mf">8.0</span><span class="p">))</span>
            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">Psiv</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">betal2</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">LightPhase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span> <span class="o">*</span> <span class="n">Bhat</span> <span class="o">-</span> <span class="n">A1_term_phase</span> <span class="o">-</span> <span class="n">A2_term_phase</span>

        <span class="n">dydt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="n">dydt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">Rv</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kvv</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Rv</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">pow</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">))</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdv</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Rd</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">pow</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Psid</span> <span class="o">-</span> <span class="n">Psiv</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">LightAmp</span>
        <span class="p">)</span>
        <span class="n">dydt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">Rd</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdd</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Rd</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="nb">pow</span><span class="p">(</span><span class="n">Rd</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">))</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kvd</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Rv</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="nb">pow</span><span class="p">(</span><span class="n">Rd</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Psid</span> <span class="o">-</span> <span class="n">Psiv</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">dydt</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">tauv</span>
            <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">kdv</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Rd</span> <span class="o">*</span> <span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">Rv</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">Rv</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Psid</span> <span class="o">-</span> <span class="n">Psiv</span><span class="p">)</span>
            <span class="o">+</span> <span class="n">LightPhase</span>
        <span class="p">)</span>
        <span class="n">dydt</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">taud</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">kvd</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">Rv</span> <span class="o">*</span> <span class="p">(</span>
            <span class="nb">pow</span><span class="p">(</span><span class="n">Rd</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">Rd</span>
        <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Psid</span> <span class="o">-</span> <span class="n">Psiv</span><span class="p">)</span>
        <span class="n">dydt</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">60.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dydt</span></div>


<div class="viewcode-block" id="HannayTP.amplitude">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.HannayTP.amplitude">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">amplitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collective ventral rhythm amplitude (Rv) of the oscillator population.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Amplitude Rv at each time point.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Integrate model and extract collective rhythm amplitude (r)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="HannayTP.phase">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.HannayTP.phase">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collective ventral phase (Psiv) of the oscillator population, wrapped to [-pi,pi].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Phase angle (radians) at each time point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Integrate model and extract collective phase (phi)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="HannayTP.cbt">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.HannayTP.cbt">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cbt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Time points corresponding to the predicted core bod temperature minima (CBTmin), derived from the</span>
<span class="sd">        ventral phase trajectory.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            Array of time points (in hours) where minima of cos(Psiv) occur, corresponding to the CBTmin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate time step (dt) between consecutive time points</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Invert cos(x) to turn the minima into maxima (peaks)</span>
        <span class="n">inverted_x</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="c1"># Identify the indices where the minima occur</span>
        <span class="n">cbt_min_indices</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">find_peaks</span><span class="p">(</span><span class="n">inverted_x</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="mf">13.0</span> <span class="o">/</span> <span class="n">dt</span><span class="p">))</span>
        <span class="c1"># Use the previous indices to find the cbtmin times</span>
        <span class="n">cbtmin_times</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="n">cbt_min_indices</span><span class="p">]</span>
        <span class="c1"># if you want to know in clock time, just do cbtmin_times % 24</span>
        <span class="k">return</span> <span class="n">cbtmin_times</span></div>
</div>



<div class="viewcode-block" id="ESRI">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.ESRI">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ESRI</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the Entrainment Signal Regularity Index (ESRI) for a given light schedule.</span>

<span class="sd">    The ESRI quantifies the strength and regularity of a light schedule by measuring how clustered</span>
<span class="sd">    the phases of a simulated circadian oscillator become after a fixed-duration exposure. A high</span>
<span class="sd">    ESRI indicates strong, regular entrainment (phases converge to a similar value), whereas a low</span>
<span class="sd">    ESRI indicates weak or irregular entrainment.</span>

<span class="sd">    The computation follows this procedure:</span>
<span class="sd">        1. Slide a window of length `window_size_days` across the input time series in steps of</span>
<span class="sd">        `esri_time_step_hours`.</span>
<span class="sd">        2. For each window start time, initialize a HannaySP model with a small amplitude and phase.</span>
<span class="sd">        3. Simulate the oscillator under the window&#39;s light input.</span>
<span class="sd">        4. Record the final amplitude as the ESRI value for that window.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    time : array_like</span>
<span class="sd">        Time points (in hours) corresponding to the provided light intensities.</span>
<span class="sd">    inputs : array_like</span>
<span class="sd">        Light intensity values (e.g., lux) at each time point.</span>
<span class="sd">    window_size_days : float, optional</span>
<span class="sd">        Size of the sliding window in days over which ESRI is computed (default: 4.0).</span>
<span class="sd">    esri_time_step_hours : float, optional</span>
<span class="sd">        Step size in hours for sliding the window (default: 1.0).</span>
<span class="sd">    initial_amplitude : float, optional</span>
<span class="sd">        Initial amplitude for the HannaySP model; should be low to represent maximal phase dispersion</span>
<span class="sd">        (default: 0.1).</span>
<span class="sd">    midnight_phase : float, optional</span>
<span class="sd">        Phase (in radians) corresponding to circadian midnight (default: 1.65238233).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    window_size : float</span>
<span class="sd">        Window length in days.</span>
<span class="sd">    esri_time_step : float</span>
<span class="sd">        Step size in hours for sliding the window.</span>
<span class="sd">    initial_amplitude : float</span>
<span class="sd">        Initial oscillator amplitude for each simulation.</span>
<span class="sd">    midnight_phase : float</span>
<span class="sd">        Phase offset for circadian midnight (radians).</span>
<span class="sd">    time_vector : ndarray</span>
<span class="sd">        Time points (hours) used for ESRI calculation.</span>
<span class="sd">    light_vector : ndarray</span>
<span class="sd">        Light intensity values corresponding to `time_vector`.</span>
<span class="sd">    raw_values : pandas.DataFrame</span>
<span class="sd">        DataFrame indexed by window start time (hours) with column `esri` for computed values.</span>
<span class="sd">    mean : float</span>
<span class="sd">        Mean ESRI value across all windows.</span>
<span class="sd">    std : float</span>
<span class="sd">        Standard deviation of ESRI values across all windows.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">window_size_days</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span>
        <span class="n">esri_time_step_hours</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">initial_amplitude</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span>
        <span class="n">midnight_phase</span><span class="o">=</span><span class="mf">1.65238233</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Set parameter values for ESRI calculation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">=</span> <span class="n">window_size_days</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">esri_time_step</span> <span class="o">=</span> <span class="n">esri_time_step_hours</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initial_amplitude</span> <span class="o">=</span> <span class="n">initial_amplitude</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">midnight_phase</span> <span class="o">=</span> <span class="n">midnight_phase</span>


        <span class="c1"># Extract time and light vector</span>
        <span class="k">if</span> <span class="n">time</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">inputs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">index</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">min</span><span class="p">())</span><span class="o">.</span><span class="n">total_seconds</span><span class="p">()</span> <span class="o">/</span> <span class="mi">3600</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">light_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide either light time series (data) or input and time.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span> <span class="o">=</span> <span class="n">time</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">light_vector</span> <span class="o">=</span> <span class="n">inputs</span>

        <span class="c1"># Calculate ESRI array, mean and standard deviation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">raw_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_values</span><span class="p">[</span><span class="s1">&#39;esri&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">std</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">raw_values</span><span class="p">[</span><span class="s1">&#39;esri&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">std</span><span class="p">()</span>


<div class="viewcode-block" id="ESRI.calculate">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.ESRI.calculate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the ESRI time points and corresponding regularity values.</span>

<span class="sd">        Returns:</span>
<span class="sd">        --------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            Dataframe indexed by window start time (hours) with column:</span>

<span class="sd">            esri : float</span>
<span class="sd">                Final oscillator amplitude (ESRI value) for each window start time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Determine the model&#39;s time step from the provided time vector</span>
        <span class="n">model_time_step</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Create an array of time points corresponding to the movement of the sliding window</span>
        <span class="n">esri_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">*</span> <span class="mi">24</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">esri_time_step</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="c1"># Array to store esri values for each time point in esri_time</span>
        <span class="n">esri_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">esri_time</span><span class="p">)</span>

        <span class="c1"># Move the sliding window to calculate all ESRI values</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">esri_time</span><span class="p">):</span>
            <span class="c1"># Initial phase in radians for the current posiition of the sliding window</span>
            <span class="n">current_phase_init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">midnight_phase</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mf">24.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">12</span><span class="p">)</span>

            <span class="c1"># Define initial condition based on initial amplitude, current_phase_init and n</span>
            <span class="n">model_initial_condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">initial_amplitude</span><span class="p">,</span> <span class="n">current_phase_init</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Generate array with model time points to later compute the corresponding light intensity values by linear interpolation</span>
            <span class="n">model_time_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="n">t</span><span class="p">,</span> <span class="n">t</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">*</span> <span class="mf">24.0</span><span class="p">,</span> <span class="n">model_time_step</span>
            <span class="p">)</span>

            <span class="c1"># Using linear interpolation, calculate light intensity value at the specified model time points, based on the time and light vector.</span>
            <span class="n">linterp_light_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                <span class="n">model_time_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">light_vector</span>
            <span class="p">)</span>

            <span class="c1"># Calculate the trajetory using the linterp_light_vector and the model_time_points</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">HannaySP</span><span class="p">(</span>
                <span class="n">inputs</span><span class="o">=</span><span class="n">linterp_light_vector</span><span class="p">,</span>
                <span class="n">time</span><span class="o">=</span><span class="n">model_time_points</span><span class="p">,</span>
                <span class="n">initial_condition</span><span class="o">=</span><span class="n">model_initial_condition</span><span class="p">,</span>
                <span class="n">k</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                <span class="n">gamma</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># model amplitude at the end of the simulation</span>
            <span class="n">esri_values</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">model_states</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Any negative values are replaced with NaN</span>
        <span class="n">esri_values</span><span class="p">[</span><span class="n">esri_values</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

        <span class="c1"># Pack the time point and the corresponding esri value into a dataframe</span>
        <span class="n">esri_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="n">esri_time</span><span class="p">,</span>
            <span class="s2">&quot;esri&quot;</span><span class="p">:</span> <span class="n">esri_values</span>
        <span class="p">})</span>

        <span class="c1"># Set &#39;time&#39; column as the index of the dataframe</span>
        <span class="n">esri_df</span> <span class="o">=</span> <span class="n">esri_df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;time&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">esri_df</span></div>
</div>



<div class="viewcode-block" id="ModelComparer">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.ModelComparer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ModelComparer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Framework for mapping FJK model states to HannaySP states (experimental).</span>

<span class="sd">    This class is currently under active development and the API may change</span>
<span class="sd">    without backward compatibility guarantees.</span>

<span class="sd">    The ModelComparer is intended to take the state variables from the</span>
<span class="sd">    ForgerJewettKronauer (FJK) model and use them to predict the state</span>
<span class="sd">    variables of the HannaySP model. By doing so, it seeks to assign a more</span>
<span class="sd">    direct physiological interpretation to the FJK outputs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">inputs</span><span class="p">,</span>
        <span class="n">time</span><span class="p">,</span>
        <span class="n">equilibrate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">loop_number</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>
        <span class="n">a1</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">a2</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">p1</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">p2</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
        <span class="n">m1</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">m2</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Translation params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a2</span> <span class="o">=</span> <span class="n">a2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1</span> <span class="o">=</span> <span class="n">m1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m2</span> <span class="o">=</span> <span class="n">m2</span>

        <span class="c1"># Light and time vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">light_vector</span> <span class="o">=</span> <span class="n">inputs</span>

        <span class="c1"># Instantiate forger model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">forger</span> <span class="o">=</span> <span class="n">Forger</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">light_vector</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">equilibrate</span><span class="p">:</span>
            <span class="c1"># First, calculate initial conditions based on the light and time vector</span>
            <span class="n">ics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forger</span><span class="o">.</span><span class="n">get_initial_conditions</span><span class="p">(</span>
                <span class="n">loop_number</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                <span class="n">light_vector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">light_vector</span><span class="p">,</span>
                <span class="n">time_vector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span><span class="p">,</span>
                <span class="n">change_params</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="c1"># Second, integrate the equilibrated model and use last state as initial conditions</span>
            <span class="n">new_ics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forger</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                <span class="n">light_vector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">light_vector</span><span class="p">,</span>
                <span class="n">time_vector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span><span class="p">,</span>
                <span class="n">initial_condition</span><span class="o">=</span><span class="n">ics</span>
            <span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Third, use the calculated initial conditions to define current model states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">forger</span><span class="o">.</span><span class="n">model_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forger</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                <span class="n">light_vector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">light_vector</span><span class="p">,</span>
                <span class="n">time_vector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span><span class="p">,</span>
                <span class="n">initial_condition</span><span class="o">=</span><span class="n">ics</span>
            <span class="p">)</span>

        <span class="c1"># Instantiate hannay model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hannay</span> <span class="o">=</span> <span class="n">HannaySP</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">light_vector</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">equilibrate</span><span class="p">:</span>
            <span class="c1"># First, calculate initial conditions based on the light and time vector</span>
            <span class="n">ics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hannay</span><span class="o">.</span><span class="n">get_initial_conditions</span><span class="p">(</span>
                <span class="n">loop_number</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
                <span class="n">light_vector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">light_vector</span><span class="p">,</span>
                <span class="n">time_vector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span><span class="p">,</span>
                <span class="n">change_params</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>

            <span class="c1"># Second, integrate the equilibrated model and use last state as initial conditions</span>
            <span class="n">new_ics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hannay</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                <span class="n">light_vector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">light_vector</span><span class="p">,</span>
                <span class="n">time_vector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span><span class="p">,</span>
                <span class="n">initial_condition</span><span class="o">=</span><span class="n">ics</span>
            <span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Third, use the calculated initial conditions to define current model states</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hannay</span><span class="o">.</span><span class="n">model_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hannay</span><span class="o">.</span><span class="n">integrate</span><span class="p">(</span>
                <span class="n">light_vector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">light_vector</span><span class="p">,</span>
                <span class="n">time_vector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span><span class="p">,</span>
                <span class="n">initial_condition</span><span class="o">=</span><span class="n">new_ics</span>
            <span class="p">)</span>

        <span class="c1"># Store state variables of the forger model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forger</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forger</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Store the collective phase of Hannay&#39;s model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_vector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hannay</span><span class="o">.</span><span class="n">model_states</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Predicted x and xc attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_x</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">predicted_xc</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Error of the prediction of x and xc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_x</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">error_xc</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="ModelComparer.predict_forger">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.ModelComparer.predict_forger">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">predict_forger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">change_params</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Predict state variable x in FJK model (either Forger or Jewett)</span>
        <span class="n">predicted_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p1</span> <span class="o">*</span> <span class="n">phase</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1</span> <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vector</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Predict state variable xc in FJK model (either Forger or Jewett)</span>
        <span class="n">predicted_xc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p2</span> <span class="o">*</span> <span class="n">phase</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">m2</span>
                <span class="k">for</span> <span class="n">phase</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vector</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Define the predicted_x and predicted_xc attributes</span>
        <span class="k">if</span> <span class="n">change_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_x</span> <span class="o">=</span> <span class="n">predicted_x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">predicted_xc</span> <span class="o">=</span> <span class="n">predicted_xc</span>

        <span class="c1"># Return predictions for x and xc as a tuple</span>
        <span class="k">return</span> <span class="n">predicted_x</span><span class="p">,</span> <span class="n">predicted_xc</span></div>


<div class="viewcode-block" id="ModelComparer.linearize_phase">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.ModelComparer.linearize_phase">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">linearize_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">change_params</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Attempt to fit a straight line (a polynomial of degree 1) to the collective phase</span>
        <span class="n">coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vector</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">slope</span><span class="p">,</span> <span class="n">intercept</span> <span class="o">=</span> <span class="n">coefficients</span>
        <span class="k">if</span> <span class="n">change_params</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phase_vector</span> <span class="o">=</span> <span class="n">slope</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span> <span class="o">+</span> <span class="n">intercept</span>
        <span class="k">return</span> <span class="n">slope</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_vector</span> <span class="o">+</span> <span class="n">intercept</span></div>


<div class="viewcode-block" id="ModelComparer.find_optimal_params">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.ModelComparer.find_optimal_params">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_optimal_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">change_params</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Define a mapping function for the state variable x in the FJK model</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">map_x</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> <span class="n">M1</span><span class="p">,</span> <span class="n">P1</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">A1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">P1</span> <span class="o">*</span> <span class="n">phase</span><span class="p">)</span> <span class="o">+</span> <span class="n">M1</span>

        <span class="c1"># Define a mapping function for the state variable xc in the FJK model</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">map_xc</span><span class="p">(</span><span class="n">phase</span><span class="p">,</span> <span class="n">A2</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">P2</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">A2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">P2</span> <span class="o">*</span> <span class="n">phase</span><span class="p">)</span> <span class="o">+</span> <span class="n">M2</span>

        <span class="c1"># Initial values for A1 and A2, M1 and M2, and P1 and P2</span>
        <span class="n">initial_guess</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_params</span><span class="p">(</span><span class="n">map_function</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="n">vector_to_predict</span><span class="p">,</span> <span class="n">phase</span><span class="p">):</span>
            <span class="c1"># Find optimal parameters using non-linear least squares regression</span>
            <span class="n">optimal_params</span><span class="p">,</span> <span class="n">covariance</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span>
                <span class="n">map_function</span><span class="p">,</span> <span class="n">phase</span><span class="p">,</span> <span class="n">vector_to_predict</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">initial_guess</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">optimal_params</span>

        <span class="c1"># Calculate A1, M1, P1, A2, M2 and P2</span>
        <span class="n">a1</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">calculate_params</span><span class="p">(</span><span class="n">map_x</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vector</span><span class="p">)</span>
        <span class="n">a2</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">calculate_params</span><span class="p">(</span><span class="n">map_xc</span><span class="p">,</span> <span class="n">initial_guess</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_vector</span><span class="p">)</span>

        <span class="c1"># Change the attributes of the object</span>
        <span class="k">if</span> <span class="n">change_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">a2</span> <span class="o">=</span> <span class="n">a2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m1</span> <span class="o">=</span> <span class="n">m1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m2</span> <span class="o">=</span> <span class="n">m2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span>

        <span class="c1"># Return a 2 * 3 matrix with parameters</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a1</span><span class="p">,</span> <span class="n">m1</span><span class="p">,</span> <span class="n">p1</span><span class="p">],</span> <span class="p">[</span><span class="n">a2</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">p2</span><span class="p">]])</span></div>


<div class="viewcode-block" id="ModelComparer.error">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.ModelComparer.error">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">change_params</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># Compute error associated with prediction</span>
        <span class="n">error_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_x</span>
        <span class="n">error_xc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xc</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">predicted_xc</span>

        <span class="c1"># Change the error_x and xc attributes</span>
        <span class="k">if</span> <span class="n">change_params</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_x</span> <span class="o">=</span> <span class="n">error_x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error_xc</span> <span class="o">=</span> <span class="n">error_xc</span>

        <span class="c1"># Return the calculated vectors</span>
        <span class="k">return</span> <span class="n">error_x</span><span class="p">,</span> <span class="n">error_xc</span></div>


<div class="viewcode-block" id="ModelComparer.error_stats">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.ModelComparer.error_stats">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">error_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">calculate_stats</span><span class="p">(</span><span class="n">prediction_error</span><span class="p">,</span> <span class="n">measure</span><span class="p">):</span>
            <span class="c1"># Max and min error for the prediction</span>
            <span class="n">max_error</span> <span class="o">=</span> <span class="n">prediction_error</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">min_error</span> <span class="o">=</span> <span class="n">prediction_error</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

            <span class="c1"># Calculate the error_band_width</span>
            <span class="n">error_band_width</span> <span class="o">=</span> <span class="n">max_error</span> <span class="o">-</span> <span class="n">min_error</span>

            <span class="c1"># Calculate the range of values for the measure</span>
            <span class="n">range_x</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">measure</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

            <span class="c1"># Calculate the magnitude of the error</span>
            <span class="n">error_magnitude</span> <span class="o">=</span> <span class="p">(</span><span class="n">error_band_width</span> <span class="o">/</span> <span class="n">range_x</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>

            <span class="c1"># Return the calculated values</span>
            <span class="k">return</span> <span class="n">max_error</span><span class="p">,</span> <span class="n">min_error</span><span class="p">,</span> <span class="n">error_band_width</span><span class="p">,</span> <span class="n">error_magnitude</span>

        <span class="c1"># Calculate x an xc error descriptive stats</span>
        <span class="n">x_stats</span> <span class="o">=</span> <span class="n">calculate_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">xc_stats</span> <span class="o">=</span> <span class="n">calculate_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">error_xc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">x_stats</span><span class="p">,</span> <span class="n">xc_stats</span></div>
</div>



<div class="viewcode-block" id="main">
<a class="viewcode-back" href="../../../../api.html#circStudio.analysis.models.math_models.main">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Parameters for the light schedule</span>
    <span class="n">total_days</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># Number of days</span>
    <span class="n">light_on_hours</span> <span class="o">=</span> <span class="mi">16</span>  <span class="c1"># Hours lights are on</span>
    <span class="n">light_off_hours</span> <span class="o">=</span> <span class="mi">8</span>  <span class="c1"># Hours lights are off</span>
    <span class="n">bins_per_hour</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># 10-minute bins per hour</span>
    <span class="c1"># bins_per_hour = 10</span>
    <span class="c1"># bins_per_hour = 1</span>

    <span class="c1"># Total bins for light on and off periods</span>
    <span class="n">light_on_bins</span> <span class="o">=</span> <span class="n">light_on_hours</span> <span class="o">*</span> <span class="n">bins_per_hour</span>
    <span class="n">light_off_bins</span> <span class="o">=</span> <span class="n">light_off_hours</span> <span class="o">*</span> <span class="n">bins_per_hour</span>

    <span class="c1"># Generate random light levels for the light-on period (e.g., between 100 and 800 lux)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
    <span class="n">light_on_variation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">low</span><span class="o">=</span><span class="mi">900</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mi">901</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">light_on_bins</span><span class="p">)</span>

    <span class="c1"># Create the daily schedule: light-off period (0 lux) followed by light-on period</span>
    <span class="n">daily_schedule</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">light_off_bins</span><span class="p">),</span> <span class="n">light_on_variation</span><span class="p">])</span>

    <span class="c1"># Repeat for the total number of days</span>
    <span class="n">light</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">daily_schedule</span><span class="p">,</span> <span class="n">total_days</span><span class="p">)</span>

    <span class="n">dt</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">/</span> <span class="mi">60</span>  <span class="c1"># 10 minutes in hours</span>
    <span class="c1">#dt = 1</span>
    <span class="c1">#dt=1/10 # for 10 bins/h</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">light</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>


    <span class="c1"># SECTION FOR COMPARING CIRCADIAN MODELS (FORGER AND HANNAY)</span>
    <span class="n">comparison</span> <span class="o">=</span> <span class="n">ModelComparer</span><span class="p">(</span><span class="n">inputs</span><span class="o">=</span><span class="n">light</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="n">time</span><span class="p">,</span> <span class="n">equilibrate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">comparison</span><span class="o">.</span><span class="n">linearize_phase</span><span class="p">(</span><span class="n">change_params</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">comparison</span><span class="o">.</span><span class="n">find_optimal_params</span><span class="p">(</span><span class="n">change_params</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">comparison</span><span class="o">.</span><span class="n">predict_forger</span><span class="p">(</span><span class="n">change_params</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">comparison</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">change_params</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">max_error_x</span><span class="p">,</span> <span class="n">min_error_x</span><span class="p">,</span> <span class="n">error_band_x</span><span class="p">,</span> <span class="n">magnitude_x</span> <span class="o">=</span> <span class="n">comparison</span><span class="o">.</span><span class="n">error_stats</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">max_error_xc</span><span class="p">,</span> <span class="n">min_error_xc</span><span class="p">,</span> <span class="n">error_band_xc</span><span class="p">,</span> <span class="n">magnitude_xc</span> <span class="o">=</span> <span class="n">comparison</span><span class="o">.</span><span class="n">error_stats</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># SECTION WITH GENERAL COMMANDS</span>
    <span class="c1"># hannay = HannaySP(inputs=light_vector, time=time_vector)</span>
    <span class="c1"># forger = HannaySP(inputs=light, time=time)</span>
    <span class="c1"># esri = ESRI(inputs=light_vector, time=time_vector)</span>
    <span class="c1"># esri.calculate()</span>

    <span class="c1"># start = time.time()</span>
    <span class="c1"># r = forger.model_states[:,1]</span>
    <span class="c1"># states = list(r)</span>
    <span class="c1"># r = jewett.integrate()[:,0]</span>
    <span class="c1"># r = hannay.amplitude()</span>
    <span class="c1"># r = hannay.phase()</span>
    <span class="c1"># x = forger.integrate()[:,1]</span>
    <span class="c1"># print(hannay.dlmos() % 24)</span>
    <span class="c1"># phi = hannay.integrate()[:, 1]</span>
    <span class="c1"># predicted_x = hannay.predict_forger()[0]</span>
    <span class="c1"># hannay.initial_conditions = np.array([1,2,3])</span>
    <span class="c1"># print(forger.equilibrate(100, light_vector, time_vector))</span>
    <span class="c1"># print(hannay.equilibrate(100, light_vector, time_vector))</span>
    <span class="c1"># end = time.time()</span>

    <span class="c1"># REGION FOR PLOTS</span>
    <span class="c1"># plt.figure(figsize=(18, 8))</span>
    <span class="c1"># plt.plot(phi)</span>
    <span class="c1"># plt.xlabel(&quot;Time&quot;)</span>
    <span class="c1"># plt.ylabel(&quot;Phi (state variable)&quot;)</span>
    <span class="c1"># plt.title(&quot;State Evolution Over Time&quot;)</span>
    <span class="c1"># plt.legend()</span>
    <span class="c1"># plt.grid(True)</span>
    <span class="c1"># plt.show()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">comparison</span><span class="o">.</span><span class="n">predicted_x</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;predicted_x&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">comparison</span><span class="o">.</span><span class="n">predicted_x</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;predicted_x&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;blue&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
    <span class="c1">#peaks,_= find_peaks(comparison.error_x)</span>
    <span class="c1">#for peak in peaks:</span>
     <span class="c1">#   print(f&#39;{comparison.error_x[peak]:.3f}&#39;)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">comparison</span><span class="o">.</span><span class="n">error_x</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Error&quot;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;pink&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">max_error_x</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;green&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Max Error&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">min_error_x</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s2">&quot;purple&quot;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s2">&quot;--&quot;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;Min error&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span>
        <span class="n">x</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">comparison</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="n">max_error_x</span> <span class="o">+</span> <span class="n">min_error_x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">s</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;Error band width </span><span class="si">{</span><span class="n">error_band_x</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="n">color</span><span class="o">=</span><span class="s2">&quot;orange&quot;</span><span class="p">,</span>
        <span class="n">ha</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
        <span class="n">va</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span>
        <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
        <span class="n">backgroundcolor</span><span class="o">=</span><span class="s2">&quot;white&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;State variable&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;State Evolution Over Time&quot;</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="c1">#print(f&quot;Magnitude of the error in predicting x = {magnitude_x}&quot;)</span>

    <span class="c1">#plt.figure()</span>
    <span class="c1">#plt.plot(comparison.predicted_xc, label=&quot;predicted_xc&quot;, color=&quot;black&quot;, alpha=0.5)</span>
    <span class="c1">#plt.plot(comparison.xc, label=&quot;observed_xc&quot;, color=&quot;blue&quot;, alpha=0.9)</span>
    <span class="c1">#plt.plot(comparison.error_xc, label=&quot;Error&quot;, color=&quot;pink&quot;, alpha=0.9)</span>
    <span class="c1">#plt.axhline(y=max_error_xc, color=&quot;green&quot;, linestyle=&quot;--&quot;, label=&quot;Max Error&quot;)</span>
    <span class="c1">#plt.axhline(y=min_error_xc, color=&quot;purple&quot;, linestyle=&quot;--&quot;, label=&quot;Min error&quot;)</span>
    <span class="c1">#plt.text(</span>
     <span class="c1">#   x=len(comparison.xc) // 2,</span>
      <span class="c1">#  y=(max_error_xc + min_error_xc) / 2,</span>
       <span class="c1"># s=f&quot;Error band width {error_band_xc:.2f}&quot;,</span>
        <span class="c1">#color=&quot;orange&quot;,</span>
        <span class="c1">#ha=&quot;center&quot;,</span>
        <span class="c1">#va=&quot;center&quot;,</span>
        <span class="c1">#fontsize=12,</span>
        <span class="c1">#backgroundcolor=&quot;white&quot;,</span>
    <span class="c1">#)</span>
    <span class="c1">#plt.xlabel(&quot;Time&quot;)</span>
    <span class="c1">#plt.ylabel(&quot;State variable&quot;)</span>
    <span class="c1">#plt.title(&quot;State Evolution Over Time&quot;)</span>
    <span class="c1">#plt.legend()</span>
    <span class="c1">#plt.grid(True)</span>
    <span class="c1">#print(f&quot;Magnitude of the error in predicting x = {magnitude_xc}&quot;)</span>

    <span class="c1"># plt.figure(figsize=(18,8))</span>
    <span class="c1"># plt.plot(comparison.error_x, label=&#39;Error&#39;, color=&#39;pink&#39;, alpha=0.9)</span>
    <span class="c1"># plt.xlabel(&quot;Time&quot;)</span>
    <span class="c1"># plt.ylabel(&quot;Error in x prediction&quot;)</span>
    <span class="c1"># plt.title(&quot;x Error Evolution Over Time&quot;)</span>
    <span class="c1"># plt.legend()</span>
    <span class="c1"># plt.grid(True)</span>

    <span class="c1"># plt.figure(figsize=(18,8))</span>
    <span class="c1"># plt.plot(comparison.error_xc, label=&#39;Error&#39;, color=&#39;pink&#39;, alpha=0.9)</span>
    <span class="c1"># plt.xlabel(&quot;Time&quot;)</span>
    <span class="c1"># plt.ylabel(&quot;Error in xc prediction&quot;)</span>
    <span class="c1"># plt.title(&quot;xc Error Evolution Over Time&quot;)</span>
    <span class="c1"># plt.legend()</span>
    <span class="c1"># plt.grid(True)</span>
    <span class="c1"># plt.figure()</span>
    <span class="c1"># plt.plot(r, label=f&#39;State r&#39;, color=&#39;blue&#39;, alpha=0.7)</span>
    <span class="c1"># plt.xlabel(&quot;Time&quot;)</span>
    <span class="c1"># plt.ylabel(f&quot;Model state r&quot;)</span>
    <span class="c1"># plt.title(f&quot;Model State r Evolution Over Time&quot;)</span>
    <span class="c1"># plt.legend()</span>
    <span class="c1"># plt.grid(True)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


    <span class="c1"># print(f&quot;Execution time is {end-start} seconds.&quot;)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Daniel Marques
</p>

  </div>
  
  <div class="footer-item">
    

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>